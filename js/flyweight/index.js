/**
 * 享元模式
 * 享元（flyweight）模式是一种用于性能优化的模式，“fly”在这里是苍蝇的意思，意为蝇量级。
 * 享元模式的核心是运用共享技术来有效支持大量细粒度的对象。
 */

// 假设有个内衣工厂，目前的产品有 50 种男式内衣和 50 种女士内衣，为了推销产品，工厂决定生产一些塑料模特来穿上他们的内衣拍成广告照片。
var Model = function( sex ){ 
    this.sex = sex; 
}; 

Model.prototype.takePhoto = function(){ 
    console.log( 'sex= ' + this.sex + ' underwear=' + this.underwear); 
};

var maleModel = new Model( 'male' ), 
    femaleModel = new Model( 'female' );

for ( var i = 1; i <= 50; i++ ){ 
    maleModel.underwear = 'underwear' + i; 
    maleModel.takePhoto(); 
};

for ( var j = 1; j <= 50; j++ ){ 
    femaleModel.underwear = 'underwear' + j; 
    femaleModel.takePhoto(); 
};

/*
    内部状态与外部状态
    享元模式要求将对象的属性划分为内部状态与外部状态（状态在这里通常指属性）。
    享元模式的目标是尽量减少共享对象的数量，关于如何划分内部状态和外部状态，下面的几条经验提供了一些指引。

        内部状态存储于对象内部。
        内部状态可以被一些对象共享。
        内部状态独立于具体的场景，通常不会改变。
        外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享。

    这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。
    而外部状态可以从对象身上剥离出来，并储存在外部。

    剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整的对象。
    虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系统中的对象数量，相比之下，这点时间或许是微不足道的。
    因此，享元模式是一种用时间换空间的优化模式。

    在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系统中的对象数量。
    通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别通常只有男女两种，所以该内衣厂商最多只需要 2 个对象。

    使用享元模式的关键是如何区别内部状态和外部状态。
    可以被对象共享的属性通常被划分为内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，
    模特的性别就可以作为内部状态储存在共享对象的内部。
    而外部状态取决于具体的场景，并根据场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外部状态。
 */


/*
    享元模式的通用结构
    示例初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中还存在以下两个问题。

        我们通过构造函数显式 new 出了男女两个 model 对象，在其他系统中，也许并不是一开始就需要所有的共享对象。

        给 model 对象手动设置了 underwear 外部状态，在更复杂的系统中，这不是一个最好的方式，
        因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。

    我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂中被创建出来。
    对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状态通过某个钩子和共享对象联系起来。
 */

/*
    享元模式的适用性
    享元模式是一种很好的性能优化方案，但它也会带来一些复杂性的问题，从前面两组代码的比较可以看到，
    使用了享元模式之后，我们需要分别多维护一个 factory 对象和一个 manager 对象，在大部分不必要使用享元模式的环境下，这些开销是可以避免的。

    享元模式带来的好处很大程度上取决于如何使用以及何时使用，一般来说，以下情况发生时便可以使用享元模式。

        一个程序中使用了大量的相似对象。
        由于使用了大量对象，造成很大的内存开销。
        对象的大多数状态都可以变为外部状态。
        剥离出对象的外部状态之后，可以用相对较少的共享对象取代大量对象。
 */
