/**
 * 代理模式
 * 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。
 */

/*
    保护代理
    代理 B 可以帮助 A 过滤掉一些请求，比如送花的人中年龄太大的或者没有宝马的，这种请求就可以直接在代理 B 处被拒绝掉。这种代理叫作保护代理。
    
    虚拟代理
    假设现实中的花价格不菲，导致在程序世界里，new Flower 也是一个代价昂贵的操作，那么我们可以把 new Flower 的操作交给代理 B 去执行，代理 B 会选择在 A 心情好时再执行 new Flower，这是代理模式的另一种形式，叫作虚拟代理。
    虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。

    保护代理用于控制不同权限的对象对目标对象的访问，但在 JavaScript 并不容易实现保护代理，因为我们无法判断谁访问了某个对象。
    而虚拟代理是最常用的一种代理模式，本章主要讨论的也是虚拟代理。
 */

/*
    单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因。
 */

/*
    代理和本体接口的一致性
    在客户看来，代理对象和本体是一致的， 代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这样做有两个好处。
    1.用户可以放心地请求代理，他只关心是否能得到想要的结果。
    2.在任何使用本体的地方都可以替换成使用代理。
 */

/*
    缓存代理
    缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。
 */

/*
    其他代理模式
    防火墙代理：控制网络资源的访问，保护主题不让“坏人”接近。
    远程代理：为一个对象在不同的地址空间提供局部代表，在 Java 中，远程代理可以是另一个虚拟机中的对象。
    保护代理：用于对象应该有不同访问权限的情况。
    智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。
    写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型运用场景。
 */


/**
 * 小明通过 B 来给 A 送花
 */
var Flower = function(){}; 

var xiaoming = { 
    sendFlower: function( target){ 
        var flower = new Flower(); 
        target.receiveFlower( flower ); 
    } 
};

var B = { 
    receiveFlower: function( flower ){ 
        A.listenGoodMood(function(){ // 监听 A 的好心情
            A.receiveFlower( flower ); 
        }); 
    } 
};

var A = { 
    receiveFlower: function( flower ){ 
        console.log( '收到花 ' + flower ); 
    }, 
    listenGoodMood: function( fn ){ 
        setTimeout(function(){ // 假设 10 秒之后 A 的心情变好
            fn(); 
        }, 10000 ); 
    } 
}; 

xiaoming.sendFlower( B );